<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>get_MER_total_mass</title>
<meta name="generator" content="MATLAB 24.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-10-07">
<meta name="DC.source" content="get_MER_total_mass.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#3">SECOND STAGE COMPUTATIONS %%</a>
</li>
<li>
<a href="#4">FIRST STAGE COMPUTATIONS %%</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="keyword">function</span> [num_engines_stage1, num_engines_stage2, stage1_only_total_mass, stage2_only_total_mass, total_mass, total_height, stage1_T_to_W, stage2_T_to_W] = get_MER_total_mass(first_stage, second_stage, X)
</pre>
<pre class="codeinput">    <span class="comment">% Sophie, Spyros, Chris</span>
    addpath(<span class="string">"..\vehicle_level_analysis_tool\"</span>)

    <span class="comment">% Set thrust to weight constants</span>
    T_to_W_first = 1.3;
    T_to_W_second = 0.76;

    <span class="comment">% Set delta, g0, payload mass, total deltaV, and tolerance constants</span>
    delta1 = 0.08;
    delta2 = 0.08;
    g0 = 9.81; <span class="comment">% m/s^2</span>
    deltaV = 12300; <span class="comment">% m/s</span>
    M_l = 26000; <span class="comment">% kg</span>
    tol = 0.01;

    <span class="comment">% Logic to set first stage Isp and thrust</span>
    <span class="keyword">if</span> first_stage == <span class="string">"LCH4"</span>
        stage1_Isp = 327; <span class="comment">% s</span>
        stage1_thrust = 2.26e6; <span class="comment">% N</span>
    <span class="keyword">elseif</span> first_stage == <span class="string">"LH2"</span>
        stage1_Isp = 366; <span class="comment">% s</span>
        stage1_thrust = 1.86e6; <span class="comment">% N</span>
    <span class="keyword">elseif</span> first_stage == <span class="string">"RP1"</span>
        stage1_Isp = 311; <span class="comment">% s</span>
        stage1_thrust = 1.92e6; <span class="comment">% N</span>
    <span class="keyword">elseif</span> first_stage == <span class="string">"solid"</span>
        stage1_Isp = 269; <span class="comment">% s</span>
        stage1_thrust = 4.5e6; <span class="comment">% N</span>
    <span class="keyword">elseif</span> first_stage == <span class="string">"storables"</span>
        stage1_Isp = 285; <span class="comment">% s</span>
        stage1_thrust = 1.75e6; <span class="comment">% N</span>
    <span class="keyword">end</span>

    <span class="comment">% Logic to set second stage Isp and thrust</span>
    <span class="keyword">if</span> second_stage == <span class="string">"LCH4"</span>
        stage2_Isp = 327; <span class="comment">% s</span>
        stage2_thrust = 0.745e6; <span class="comment">% N</span>
    <span class="keyword">elseif</span> second_stage == <span class="string">"LH2"</span>
        stage2_Isp = 366;
        stage2_thrust = 0.099e6; <span class="comment">% N</span>
    <span class="keyword">elseif</span> second_stage == <span class="string">"RP1"</span>
        stage2_Isp = 311; <span class="comment">% s</span>
        stage2_thrust = 0.061e6; <span class="comment">% N</span>
    <span class="keyword">elseif</span> second_stage == <span class="string">"solid"</span>
        stage2_Isp = 269; <span class="comment">% s</span>
        stage2_thrust = 2.94e6; <span class="comment">% N</span>
    <span class="keyword">elseif</span> second_stage == <span class="string">"storables"</span>
        stage2_Isp = 285; <span class="comment">% s</span>
        stage2_thrust = 0.067e6; <span class="comment">% N</span>
    <span class="keyword">end</span>
</pre>
<pre class="codeoutput error">Not enough input arguments.

Error in get_MER_total_mass (line 18)
    if first_stage == "LCH4"
       ^^^^^^^^^^^</pre>
<h2 id="3">SECOND STAGE COMPUTATIONS %%</h2>
<p>Get initial guess from mass_function</p>
<pre class="codeinput">    deltaV2_frac = deltaV*(1-X);
    r = exp(-deltaV2_frac/(g0*stage2_Isp));
    [m_in1, m_in2, m_pr1, m_pr2, m0] = mass_function(stage1_Isp, stage2_Isp, X, delta1, delta2);

    <span class="comment">% Set propellant and total mass (with mass margin)</span>
    M_p = m_pr2;
    M_0 = 1.3*m_in2 + M_l + M_p;

    <span class="comment">% Call get_stage2_mass for initial guess using guess from mass_function</span>
    stage2_total_mass = get_stage2_mass(second_stage, M_p, M_0, 1, true);

    <span class="comment">% Compute initial guess for number of engines</span>
    num_engines_stage2 = ceil(stage2_total_mass*g0*T_to_W_second/stage2_thrust);

    <span class="comment">% Set single engine thrust and residual that will be continuously</span>
    <span class="comment">% checked in convergence loop</span>
    stage2_thrust_single = stage2_thrust;
    residual = realmax;

    <span class="keyword">if</span> second_stage ~= <span class="string">"solid"</span>
        <span class="keyword">while</span> residual &gt; tol

            <span class="comment">% Set M_p and M_0 using mass margin</span>
            M_p = stage2_total_mass*(1-r);
            M_0 = (stage2_total_mass - M_p- M_l)*1.3 + M_l + M_p;

            <span class="comment">% Call get_stage2_mass, compute number of engines considering</span>
            <span class="comment">% mass margin, compute residual</span>
            [stage2_total_mass, stage2_height] = get_stage2_mass(second_stage, M_p, M_0, num_engines_stage2, false);
            margin_stage2_total_mass = (stage2_total_mass - M_p - M_l)*1.3 + M_l + M_p;
            num_engines_stage2 = ceil(margin_stage2_total_mass*g0*T_to_W_second/stage2_thrust_single);
            residual = abs(margin_stage2_total_mass - M_0);
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="comment">% Slightly different for solids, not an convergence loop</span>
        <span class="comment">% Compute mass with margin and required engines. Run</span>
        <span class="comment">% get_stage2_mass. Check to see if new required number of engines</span>
        <span class="comment">% is the same as before (most likely will be). If not, make it the</span>
        <span class="comment">% new number of engines that satisfy thrust to weight ratio</span>
        margin_stage2_total_mass = (stage2_total_mass - M_l- M_p)*1.3 + M_l + M_p;
        num_engines_required = ceil(margin_stage2_total_mass*g0*T_to_W_second/stage2_thrust_single);
        [stage2_total_mass, stage2_height] = get_stage2_mass(second_stage, M_p, M_0, num_engines_required, false);
        margin_stage2_total_mass = (stage2_total_mass - M_l - M_p)*1.3 + M_l + M_p;
        num_engines_required_recompued = ceil(margin_stage2_total_mass*g0*T_to_W_second/stage2_thrust_single);
        <span class="keyword">if</span> ceil(num_engines_required) ~= ceil(num_engines_required_recompued)
            num_engines_stage2 = ceil(num_engines_required_recompued);
        <span class="keyword">else</span>
            num_engines_stage2 = ceil(num_engines_required);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre>
<h2 id="4">FIRST STAGE COMPUTATIONS %%</h2>
<p>Get initial guess from mass_function</p>
<pre class="codeinput">    deltaV1_frac = deltaV*X;
    r = exp(-deltaV1_frac/(g0*stage1_Isp));
    [m_in1, m_in2, m_pr1, m_pr2, m0] = mass_function(stage1_Isp, stage2_Isp, X, delta1, delta2);

    <span class="comment">% Set propellant and total mass (with mass margin)</span>
    M_p = m_pr1;
    M_0 = (m0 - M_l - m_pr1)*1.3 + M_l + m_pr1;

    <span class="comment">% Call get_stage1_mass for initial guess using guess from mass_function</span>
    stage1_total_mass = get_stage1_mass(first_stage, M_p, M_0, stage2_total_mass, 1, true);

    <span class="comment">% Compute initial guess for number of engines</span>
    num_engines_stage1 = stage1_total_mass*g0*T_to_W_first/stage1_thrust;

    <span class="comment">% Set single engine thrust and residual that will be continuously</span>
    stage1_thrust_single = stage1_thrust;
    residual = realmax;

    <span class="keyword">if</span> first_stage ~= <span class="string">"solid"</span>
        <span class="keyword">while</span> residual &gt; tol

            <span class="comment">% Set M_p and M_0 using mass margin</span>
            M_p = stage1_total_mass*(1-r);
            M_0 = (stage1_total_mass - M_p - margin_stage2_total_mass)*1.3 + margin_stage2_total_mass + M_p;

            <span class="comment">% Call get_stage1_mass, compute number of engines considering</span>
            <span class="comment">% mass margin and stage2 mass, compute residual</span>
            [stage1_total_mass, stage1_height] = get_stage1_mass(first_stage, M_p, M_0, margin_stage2_total_mass, num_engines_stage1, false);
            margin_stage1_total_mass = (stage1_total_mass - M_p - margin_stage2_total_mass)*1.3 + margin_stage2_total_mass + M_p;
            num_engines_stage1 = ceil(margin_stage1_total_mass*g0*T_to_W_first/stage1_thrust_single);
            residual = abs(margin_stage1_total_mass - M_0);
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="comment">% Slightly different for solids, not an convergence loop</span>
        <span class="comment">% Compute mass with margin and required engines. Run</span>
        <span class="comment">% get_stage2_mass. Check to see if new required number of engines</span>
        <span class="comment">% is the same as before (most likely will be). If not, make it the</span>
        <span class="comment">% new number of engines that satisfy thrust to weight ratio</span>
        margin_stage1_total_mass = (stage1_total_mass - M_p - margin_stage2_total_mass)*1.3 + margin_stage2_total_mass + M_p;
        num_engines_required = ceil(margin_stage1_total_mass*g0*T_to_W_first/stage1_thrust_single);
        [stage1_total_mass, stage1_height] = get_stage1_mass(first_stage, M_p, M_0, stage2_total_mass, num_engines_required, false);
        margin_stage1_total_mass = (stage1_total_mass - M_p - margin_stage2_total_mass)*1.3 + margin_stage2_total_mass + M_p;
        num_engines_required_recompued = ceil(margin_stage1_total_mass*g0*T_to_W_first/stage1_thrust_single);
        <span class="keyword">if</span> ceil(num_engines_required) ~= ceil(num_engines_required_recompued)
            num_engines_stage1 = ceil(num_engines_required_recompued);
        <span class="keyword">else</span>
            num_engines_stage1 = ceil(num_engines_required);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Compute total height</span>
    total_height = stage1_height + stage2_height;

    <span class="comment">% Compute avionics mass and set as workspace variable</span>
    mass_avionics = 10*stage1_total_mass^(0.361);
    assignin(<span class="string">'base'</span>, <span class="string">'mass_avionics'</span>, mass_avionics);

    <span class="comment">% Compute stage only masses</span>
    stage1_only_total_mass = margin_stage1_total_mass - margin_stage2_total_mass - M_l + mass_avionics*1.3;
    stage2_only_total_mass = margin_stage2_total_mass - M_l + mass_avionics*1.3;

    <span class="comment">% Compute total masses</span>
    stage1_total_mass = margin_stage1_total_mass + mass_avionics*1.3;
    stage2_total_mass = margin_stage2_total_mass + mass_avionics*1.3;
    total_mass = stage1_total_mass;

    <span class="comment">% Get number of engines per stage</span>
    num_engines_stage1 = ceil(num_engines_stage1);
    num_engines_stage2 = ceil(num_engines_stage2);

    <span class="comment">% Output thrust to weight to ensure it meets requirement</span>
    stage2_T_to_W = num_engines_stage2*stage2_thrust_single/g0/stage2_total_mass;
    stage1_T_to_W = num_engines_stage1*stage1_thrust_single/g0/stage1_total_mass;
</pre>
<pre class="codeinput">
<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
function [num_engines_stage1, num_engines_stage2, stage1_only_total_mass, stage2_only_total_mass, total_mass, total_height, stage1_T_to_W, stage2_T_to_W] = get_MER_total_mass(first_stage, second_stage, X)
    % Sophie, Spyros, Chris
    addpath("..\vehicle_level_analysis_tool\")
    
    % Set thrust to weight constants
    T_to_W_first = 1.3;
    T_to_W_second = 0.76;
    
    % Set delta, g0, payload mass, total deltaV, and tolerance constants
    delta1 = 0.08;
    delta2 = 0.08;
    g0 = 9.81; % m/s^2
    deltaV = 12300; % m/s
    M_l = 26000; % kg
    tol = 0.01;

    % Logic to set first stage Isp and thrust
    if first_stage == "LCH4"
        stage1_Isp = 327; % s
        stage1_thrust = 2.26e6; % N
    elseif first_stage == "LH2"
        stage1_Isp = 366; % s
        stage1_thrust = 1.86e6; % N
    elseif first_stage == "RP1"
        stage1_Isp = 311; % s
        stage1_thrust = 1.92e6; % N
    elseif first_stage == "solid"
        stage1_Isp = 269; % s
        stage1_thrust = 4.5e6; % N
    elseif first_stage == "storables"
        stage1_Isp = 285; % s
        stage1_thrust = 1.75e6; % N
    end
    
    % Logic to set second stage Isp and thrust
    if second_stage == "LCH4"
        stage2_Isp = 327; % s
        stage2_thrust = 0.745e6; % N
    elseif second_stage == "LH2"
        stage2_Isp = 366;
        stage2_thrust = 0.099e6; % N
    elseif second_stage == "RP1"
        stage2_Isp = 311; % s
        stage2_thrust = 0.061e6; % N
    elseif second_stage == "solid"
        stage2_Isp = 269; % s
        stage2_thrust = 2.94e6; % N
    elseif second_stage == "storables"
        stage2_Isp = 285; % s
        stage2_thrust = 0.067e6; % N
    end
    
    %% SECOND STAGE COMPUTATIONS %%

    % Get initial guess from mass_function
    deltaV2_frac = deltaV*(1-X);
    r = exp(-deltaV2_frac/(g0*stage2_Isp));
    [m_in1, m_in2, m_pr1, m_pr2, m0] = mass_function(stage1_Isp, stage2_Isp, X, delta1, delta2);
    
    % Set propellant and total mass (with mass margin)
    M_p = m_pr2;
    M_0 = 1.3*m_in2 + M_l + M_p;
    
    % Call get_stage2_mass for initial guess using guess from mass_function
    stage2_total_mass = get_stage2_mass(second_stage, M_p, M_0, 1, true);
    
    % Compute initial guess for number of engines
    num_engines_stage2 = ceil(stage2_total_mass*g0*T_to_W_second/stage2_thrust);
    
    % Set single engine thrust and residual that will be continuously
    % checked in convergence loop
    stage2_thrust_single = stage2_thrust;
    residual = realmax;
    
    if second_stage ~= "solid"
        while residual > tol
            
            % Set M_p and M_0 using mass margin
            M_p = stage2_total_mass*(1-r);
            M_0 = (stage2_total_mass - M_p- M_l)*1.3 + M_l + M_p;
        
            % Call get_stage2_mass, compute number of engines considering
            % mass margin, compute residual
            [stage2_total_mass, stage2_height] = get_stage2_mass(second_stage, M_p, M_0, num_engines_stage2, false);
            margin_stage2_total_mass = (stage2_total_mass - M_p - M_l)*1.3 + M_l + M_p;
            num_engines_stage2 = ceil(margin_stage2_total_mass*g0*T_to_W_second/stage2_thrust_single);
            residual = abs(margin_stage2_total_mass - M_0);
        end   
    else
        % Slightly different for solids, not an convergence loop
        % Compute mass with margin and required engines. Run
        % get_stage2_mass. Check to see if new required number of engines
        % is the same as before (most likely will be). If not, make it the
        % new number of engines that satisfy thrust to weight ratio
        margin_stage2_total_mass = (stage2_total_mass - M_l- M_p)*1.3 + M_l + M_p;
        num_engines_required = ceil(margin_stage2_total_mass*g0*T_to_W_second/stage2_thrust_single);
        [stage2_total_mass, stage2_height] = get_stage2_mass(second_stage, M_p, M_0, num_engines_required, false);
        margin_stage2_total_mass = (stage2_total_mass - M_l - M_p)*1.3 + M_l + M_p;
        num_engines_required_recompued = ceil(margin_stage2_total_mass*g0*T_to_W_second/stage2_thrust_single);
        if ceil(num_engines_required) ~= ceil(num_engines_required_recompued)
            num_engines_stage2 = ceil(num_engines_required_recompued);
        else
            num_engines_stage2 = ceil(num_engines_required);
        end
    end
    
    %% FIRST STAGE COMPUTATIONS %%

    % Get initial guess from mass_function
    deltaV1_frac = deltaV*X;
    r = exp(-deltaV1_frac/(g0*stage1_Isp));
    [m_in1, m_in2, m_pr1, m_pr2, m0] = mass_function(stage1_Isp, stage2_Isp, X, delta1, delta2);
    
    % Set propellant and total mass (with mass margin)
    M_p = m_pr1;
    M_0 = (m0 - M_l - m_pr1)*1.3 + M_l + m_pr1;
    
    % Call get_stage1_mass for initial guess using guess from mass_function
    stage1_total_mass = get_stage1_mass(first_stage, M_p, M_0, stage2_total_mass, 1, true);
    
    % Compute initial guess for number of engines
    num_engines_stage1 = stage1_total_mass*g0*T_to_W_first/stage1_thrust;
    
    % Set single engine thrust and residual that will be continuously
    stage1_thrust_single = stage1_thrust;
    residual = realmax;
    
    if first_stage ~= "solid"
        while residual > tol
        
            % Set M_p and M_0 using mass margin
            M_p = stage1_total_mass*(1-r);
            M_0 = (stage1_total_mass - M_p - margin_stage2_total_mass)*1.3 + margin_stage2_total_mass + M_p;
        
            % Call get_stage1_mass, compute number of engines considering
            % mass margin and stage2 mass, compute residual
            [stage1_total_mass, stage1_height] = get_stage1_mass(first_stage, M_p, M_0, margin_stage2_total_mass, num_engines_stage1, false);
            margin_stage1_total_mass = (stage1_total_mass - M_p - margin_stage2_total_mass)*1.3 + margin_stage2_total_mass + M_p;
            num_engines_stage1 = ceil(margin_stage1_total_mass*g0*T_to_W_first/stage1_thrust_single);
            residual = abs(margin_stage1_total_mass - M_0);
        end
    else
        % Slightly different for solids, not an convergence loop
        % Compute mass with margin and required engines. Run
        % get_stage2_mass. Check to see if new required number of engines
        % is the same as before (most likely will be). If not, make it the
        % new number of engines that satisfy thrust to weight ratio
        margin_stage1_total_mass = (stage1_total_mass - M_p - margin_stage2_total_mass)*1.3 + margin_stage2_total_mass + M_p;
        num_engines_required = ceil(margin_stage1_total_mass*g0*T_to_W_first/stage1_thrust_single);
        [stage1_total_mass, stage1_height] = get_stage1_mass(first_stage, M_p, M_0, stage2_total_mass, num_engines_required, false);
        margin_stage1_total_mass = (stage1_total_mass - M_p - margin_stage2_total_mass)*1.3 + margin_stage2_total_mass + M_p;
        num_engines_required_recompued = ceil(margin_stage1_total_mass*g0*T_to_W_first/stage1_thrust_single);
        if ceil(num_engines_required) ~= ceil(num_engines_required_recompued)
            num_engines_stage1 = ceil(num_engines_required_recompued);
        else
            num_engines_stage1 = ceil(num_engines_required);
        end
    end

    % Compute total height
    total_height = stage1_height + stage2_height;

    % Compute avionics mass and set as workspace variable
    mass_avionics = 10*stage1_total_mass^(0.361);
    assignin('base', 'mass_avionics', mass_avionics);

    % Compute stage only masses
    stage1_only_total_mass = margin_stage1_total_mass - margin_stage2_total_mass - M_l + mass_avionics*1.3;
    stage2_only_total_mass = margin_stage2_total_mass - M_l + mass_avionics*1.3;
    
    % Compute total masses
    stage1_total_mass = margin_stage1_total_mass + mass_avionics*1.3;
    stage2_total_mass = margin_stage2_total_mass + mass_avionics*1.3;
    total_mass = stage1_total_mass;

    % Get number of engines per stage
    num_engines_stage1 = ceil(num_engines_stage1);
    num_engines_stage2 = ceil(num_engines_stage2);

    % Output thrust to weight to ensure it meets requirement
    stage2_T_to_W = num_engines_stage2*stage2_thrust_single/g0/stage2_total_mass;
    stage1_T_to_W = num_engines_stage1*stage1_thrust_single/g0/stage1_total_mass;

end

##### SOURCE END #####
-->
</body>
</html>
